# Bomblab

针对自学材料的bomblab解题过程。

## phase_1

disas phase_1查看对应函数的汇编代码，发现其将0x402400作为第二个参数传入strings_not_equal 函数，如果该函数返回值为0,函数结束，否则引爆炸弹。

因此，合理推测其是在比较输入的字符串和0x402400处的字符串，通过在gdb中输入x/s 0x402400查看该处的字符串得到答案。

## phase_2

从汇编代码中看见了“read_six_numbers"，推测第二个字符串为6个数字。

cmpl   $0x1,(%rsp)  那段说明第一个数得是1，否则会引爆炸弹

如果第一个数是1，之后的代码跳转到的位置将rsp中值复制给eax并翻倍，并和下一个数字比较，如果相等则rbx更新为下一个数字的地址，并比较是否比完了六个数字。

翻译成c代码大概是在做下面的事

```c
int x = 1;
for (int i = 0; i < 6; i++) {
    if (x != a[i]) explode_bomb();
    x = x * 2;
}
```

因此答案是1 2 4 8 16 32

## phase_3

%eax比1大时炸弹不会被引爆

第四个参数和第三个参数被设为了M[R[rsp]+12]和M[R[rsp]+8]处的值，第二个参数被设为了0x4025cf，eax被设为0,

用x/s 0x4025cf发现对应的字符串是%d %d， 推测之后的callq 400bf0输入了两个int

eax储存的是函数的返回值，sscanf的返回值是成功读入的数字个数。

重新在gdb中运行程序，在phase_3输入两个整数（我输入的是1和4）

读入少于两个整数将引爆炸弹。

否则跳转到400f6a，判断M[R[rsp]+8]位置上的数是否比7大，若是，跳转到400fad引爆炸弹，否则将M[R[rsp]+8]上的数复制到eax中，跳转至0x402470(, %rax, 8)指向的位置上的值所储存的位置（间接跳转），其会根据不同的rax中存的值进行跳转。而rax中的值此时就是eax中的值，即读入的第一个数字（可以通过x/32b $rsp验证）。可以通过gdb的”p/x *地址“命令查看该地址的值，看看程序将会跳转到哪里。如果第一个输入的整数为1,那么这里显示的值为0x400fb9，说明程序将会跳转到该位置。

观察代码的对应位置，其将0x137存入eax，并与第二个参数进行比较，这段代码说明若第一个参数为1,第二个参数就得是0x137，即十进制下的311.

## phase_4











