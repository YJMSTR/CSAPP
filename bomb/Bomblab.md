# Bomblab

针对自学材料的bomblab解题过程。

## phase_1

disas phase_1查看对应函数的汇编代码，发现其将0x402400作为第二个参数传入strings_not_equal 函数，如果该函数返回值为0,函数结束，否则引爆炸弹。

因此，合理推测其是在比较输入的字符串和0x402400处的字符串，通过在gdb中输入x/s 0x402400查看该处的字符串得到答案。

## phase_2

从汇编代码中看见了“read_six_numbers"，推测第二个字符串为6个数字。

cmpl   $0x1,(%rsp)  那段说明第一个数得是1，否则会引爆炸弹

如果第一个数是1，之后的代码跳转到的位置将rsp中值复制给eax并翻倍，并和下一个数字比较，如果相等则rbx更新为下一个数字的地址，并比较是否比完了六个数字。

翻译成c代码大概是在做下面的事

```c
int x = 1;
for (int i = 0; i < 6; i++) {
    if (x != a[i]) explode_bomb();
    x = x * 2;
}
```

因此答案是1 2 4 8 16 32

## phase_3

%eax比1大时炸弹不会被引爆

第四个参数和第三个参数被设为了M[R[rsp]+12]和M[R[rsp]+8]处的值，第二个参数被设为了0x4025cf，eax被设为0,

用x/s 0x4025cf发现对应的字符串是%d %d， 推测之后的callq 400bf0输入了两个int

eax储存的是函数的返回值，sscanf的返回值是成功读入的数字个数。

重新在gdb中运行程序，在phase_3输入两个整数（我输入的是1和4）

读入少于两个整数将引爆炸弹。

否则跳转到400f6a，判断M[R[rsp]+8]位置上的数是否比7大，若是，跳转到400fad引爆炸弹，否则将M[R[rsp]+8]上的数复制到eax中，跳转至0x402470(, %rax, 8)指向的位置上的值所储存的位置（间接跳转），其会根据不同的rax中存的值进行跳转。而rax中的值此时就是eax中的值，即读入的第一个数字（可以通过x/32b $rsp验证）。可以通过gdb的”p/x *地址“命令查看该地址的值，看看程序将会跳转到哪里。如果第一个输入的整数为1,那么这里显示的值为0x400fb9，说明程序将会跳转到该位置。

观察代码的对应位置，其将0x137存入eax，并与第二个参数进行比较，这段代码说明若第一个参数为1,第二个参数就得是0x137，即十进制下的311.

## phase_4

前半段代码和上一题一样，还是读入两个整数，如果sscanf返回值不等于2就引爆炸弹。随后是将第一个读入的数和0xe比，小于等于则跳转，否则引爆炸弹。跳转后edx，esi，edi的值分别被设为了0xe，0，第一个读入的值，随后调用函数func4。

func4开头将eax设为0xe，并复制进ecx，随后将ecx逻辑右移31位（等于0），加到eax上（此时eax应仍为0xe），随后sar %eax表示将eax算数右移一位（00....1111->00..0111）。接下来将%ecx设为R[rax]+R[rsi]，并比较ecx和edi的值，在小于等于时跳转至0x400ff2，否则将%edx设为R[rcx]-1，并递归调用func4。在调用完成后将eax中的值翻倍并跳转至函数结束。

0x400ff2处执行的操作为：将eax设为0并比较ecx和edi的值，在大于等于时跳转至函数结束，否则将esi设为R[rcx]+1并递归调用func4,随后将eax设为R[rax]+R[rax]+1并退出。

将func4翻译成c代码如下

```c
si = 0;
dx = 15;
di = read();
//di是第一个读入的值
int func4() {
    int ax = dx;
    ax -= si;
    int cx = ax;
    ax += cx >> 31;
    ax >>= 1;
    cx = ax + si;
    if (cx <= di) {
        ax = 0;
        if (cx >= di) {
            return ax;
        } else {
            si = cx+1;
            ax = 2*func4()+1;
        }
    } else {
        dx = cx - 1;
        ax = 2*func4();
        return ax;
    }
}
```

随后回到phase_4,其剩余的代码在判断func4的返回值是否为0，若非0将会引爆炸弹。因此上述 c语言代码的返回值ax应为0，问题转为确定di的值使得ax为0.

初始时，在进入第一个if之前cx和ax的值为7, 若cx==di，程序将直接返回0, 因此第一个数输入7合法。

随后比较第二个输入的数和0的值，若相等将返回，否则会引爆炸弹。因此第二个数为0.

## phase_5

%fs:28 是在通过段寻址从内存中读入金丝雀（canary）值，在本题中可以暂时无视。

继续向下看得知，输入的字符串长为6，底下的跳转到0x40108b部分是一个循环执行了六次，每次操作时会将读入的一个字符存入rdx中，并取其低4位作为edx的值。随后将M[R[%rdx]+0x4024b0]的值的低32位作为%edx的新值。0x4024b0处的字符串是"maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"。

那么这个程序做的是：读入一个长为6的字符串，将每个字母变为0x4024b0向后移动该字母ascii码的低4位对应的字母，最终要变成目标字符串“flyers”。对应的偏移量分别为“9 15 14 5 6 7”，对着ascii码表构造字符串即可。我构造的是“IONEFG”

## phase_6

看见汇编代码里的read_six_numbers，说明本题输入的是六个整数

在调用read_six_numbers()之后，通过‘x/32b $rsp’命令知，读入的六个整数被存放在%rsp到0x18(%rsp)之间（每四个字节存一个数）

此时%r13中存放的值为栈顶值，其指向的地址存放的是读入的第一个整数。接下来的语句将该整数复制到%eax中，将其减1并与5比大小。若该整数大于5,则会引爆炸弹。

随后程序将%r12d（初始值为0） 加1后与6比大小，在等于6时跳转至401153，否则将%ebx设为%r12d，将%rax设为%ebx，将%eax设为M[%rsp + 4*%rax]，即第%rax+1个读入的整数，将其与M[%rbp]比较，若相等则会引爆炸弹。否则将%ebx加1后与5比较，在小于等于5时跳转回“将%rax设为%ebx"那一步骤，否则继续。

上面一段对应的部分（到40114b）翻译成c代码如下

```c
int a[6];
int r13 = 0;
_401114:
if (a[r13] - 1 > 5) explode_bomb();
int bp = r13;
int i = 0;
while (i < 6) {
    i++;
    if (i == 6) {
        goto _401153;
    }
    bx = i;
_401135:
    ax = bx;
    ax = a[ax];
    if (ax != a[bp]) {
        bx++;
        if (bx <= 5) {
            goto _401135;
        } else {
            r13++;
            goto _401114; 
        }
    } else {
        explode_bomb();
    }
}
```

不难看出，程序是在检查**输入的六个整数是否全部小于等于6，且两两不同**。如果有重复元素，就会引爆炸弹。

接下来看401153处的代码，这段代码将读入的六个整数进行转换，假设读入的数字为x，那么在执行完这段代码后x将被改为7-x。即**原先输入的6个数在这里变成了7与其自身的差**

随后，esi被设为0，跳转至401197：将ecx设为M[R[rsp]+R[rsi]]，比较其与1的大小，若ecx小于等于1，跳转至401183；否则，eax被设为1，edx被设为0x6032d0，跳转回401176：将rdx设为M[rdx+8]处的值，将eax加1和ecx比大小，若不等于ecx则跳转回401176，否则跳转至401188。此处是一个循环的嵌套，写成c语言(先逐行翻译成带goto的c语言，再把goto换成循环)大概长这样：

```c
esi = 0;
goto _401197;
_401176:
rdx = M[rdx + 8];
eax++;
if (eax != ecx) {
    goto _401176;
} else goto _401188;
edx = 0x6032d0;
_401188:
M[rsp+2*rsi + 32] = rdx;
rsi += 4;
if (rsi == 24) {
    goto _4011ab;
}
_401197:
ecx = M[R[rsp] + R[rsi]];
if (ecx <= 1) {
    goto _401183;
} else {
    eax = 1;
    edx = 0x6032d0;
    goto _401176;
} 
_4011ab:
rbx = M[rsp + 32];
rax = rsp + 40;
rsi = rsp + 80;
rcx = rbx;
rdx = M[rax];
M[rcx+8] = rdx;
rax += 8;
if (rax == rsi) goto _4011d2;
rcx = rdx;
goto _4011bd;
M[rdx+8] = 0;
ebp = 5;
_4011df:
rax = M[rbx+8];
if (M[rbx] >= eax) goto _4011ee;
else explode_bomb();
_4011ee:
rbx = M[rbx+8];
ebp--;
if (ebp) goto _4011df;


```



观察到0x6032d0这个东西，用x/b查看发现标签node1​，猜想这是某种数据结构，多试几次发现一共有node1到node6 6个标签，每个node对应16个字节。

用x/32 0x6032d0打出来发现，每个node存有4个值，第四个值始终是0， 我们将其无视掉。

其中nodei的第二个值为第i个输入的整数，第三个值为下一个node的地址。node6的第三个值为0，所以这些node是个链表

翻译成c代码长这样

```c
struct node {
	int x;
    int input_data;
    node *nxt;
}
```

发现上面这三个元素已经吃满16个字节了，不清楚第四个值是什么，也许是内存对齐占的空间。

而gdb显示这六个node的x值依次为332， 168， 924， 691， 477， 443







