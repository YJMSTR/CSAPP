# Bomblab

针对自学材料的bomblab解题过程。

## phase_1

disas phase_1查看对应函数的汇编代码，发现其将0x402400作为第二个参数传入strings_not_equal 函数，如果该函数返回值为0,函数结束，否则引爆炸弹。

因此，合理推测其是在比较输入的字符串和0x402400处的字符串，通过在gdb中输入x/s 0x402400查看该处的字符串得到答案。

## phase_2

从汇编代码中看见了“read_six_numbers"，推测第二个字符串为6个数字。

cmpl   $0x1,(%rsp)  那段说明第一个数得是1，否则会引爆炸弹

如果第一个数是1，之后的代码跳转到的位置将rsp中值复制给eax并翻倍，并和下一个数字比较，如果相等则rbx更新为下一个数字的地址，并比较是否比完了六个数字。

翻译成c代码大概是在做下面的事

```c
int x = 1;
for (int i = 0; i < 6; i++) {
    if (x != a[i]) explode_bomb();
    x = x * 2;
}
```

因此答案是1 2 4 8 16 32

## phase_3

%eax比1大时炸弹不会被引爆

第四个参数和第三个参数被设为了M[R[rsp]+12]和M[R[rsp]+8]处的值，第二个参数被设为了0x4025cf，eax被设为0,

用x/s 0x4025cf发现对应的字符串是%d %d， 推测之后的callq 400bf0输入了两个int

eax储存的是函数的返回值，sscanf的返回值是成功读入的数字个数。

重新在gdb中运行程序，在phase_3输入两个整数（我输入的是1和4）

读入少于两个整数将引爆炸弹。

否则跳转到400f6a，判断M[R[rsp]+8]位置上的数是否比7大，若是，跳转到400fad引爆炸弹，否则将M[R[rsp]+8]上的数复制到eax中，跳转至0x402470(, %rax, 8)指向的位置上的值所储存的位置（间接跳转），其会根据不同的rax中存的值进行跳转。而rax中的值此时就是eax中的值，即读入的第一个数字（可以通过x/32b $rsp验证）。可以通过gdb的”p/x *地址“命令查看该地址的值，看看程序将会跳转到哪里。如果第一个输入的整数为1,那么这里显示的值为0x400fb9，说明程序将会跳转到该位置。

观察代码的对应位置，其将0x137存入eax，并与第二个参数进行比较，这段代码说明若第一个参数为1,第二个参数就得是0x137，即十进制下的311.

## phase_4

前半段代码和上一题一样，还是读入两个整数，如果sscanf返回值不等于2就引爆炸弹。随后是将第一个读入的数和0xe比，小于等于则跳转，否则引爆炸弹。跳转后edx，esi，edi的值分别被设为了0xe，0，第一个读入的值，随后调用函数func4。

func4开头将eax设为0xe，并复制进ecx，随后将ecx逻辑右移31位（等于0），加到eax上（此时eax应仍为0xe），随后sar %eax表示将eax算数右移一位（00....1111->00..0111）。接下来将%ecx设为R[rax]+R[rsi]，并比较ecx和edi的值，在小于等于时跳转至0x400ff2，否则将%edx设为R[rcx]-1，并递归调用func4。在调用完成后将eax中的值翻倍并跳转至函数结束。

0x400ff2处执行的操作为：将eax设为0并比较ecx和edi的值，在大于等于时跳转至函数结束，否则将esi设为R[rcx]+1并递归调用func4,随后将eax设为R[rax]+R[rax]+1并退出。

将func4翻译成c代码如下

```c
si = 0;
dx = 15;
di = read();
//di是第一个读入的值
int func4() {
    int ax = dx;
    ax -= si;
    int cx = ax;
    ax += cx >> 31;
    ax >>= 1;
    cx = ax + si;
    if (cx <= di) {
        ax = 0;
        if (cx >= di) {
            return ax;
        } else {
            si = cx+1;
            ax = 2*func4()+1;
        }
    } else {
        dx = cx - 1;
        ax = 2*func4();
        return ax;
    }
}
```

随后回到phase_4,其剩余的代码在判断func4的返回值是否为0，若非0将会引爆炸弹。因此上述 c语言代码的返回值ax应为0，问题转为确定di的值使得ax为0.

初始时，在进入第一个if之前cx和ax的值为7, 若cx==di，程序将直接返回0, 因此第一个数输入7合法。

随后比较第二个输入的数和0的值，若相等将返回，否则会引爆炸弹。因此第二个数为0.

## phase_5

%fs:28 是在通过段寻址从内存中读入金丝雀（canary）值，在本题中可以暂时无视。

继续向下看得知，输入的字符串长为6，R[eax]被设为0，随后跳转至40108b，R[cx]被设为R[bx]+R[ax]，M[R[rsp]]被设为R[cl]，R[dx]又被设为M[R[rsp]]，即R[cl]，随后R[dx] =  R[dx] & 0xf;

